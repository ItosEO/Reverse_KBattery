# KBattery 续航预测功能分析文档

## 概述

KBattery 是一款 Android 电池管理应用，其核心功能是**电池续航预测**。该功能通过监控电池状态、计算功耗，并基于历史数据预测剩余使用时间和满电续航时间。

---

## 一、功能架构

### 1.1 核心组件

续航预测功能主要由以下组件构成：

| 组件 | 文件 | 职责 |
|------|------|------|
| **主界面** | `BatteryActivity.java` | 显示电池信息、续航预测结果、用户交互 |
| **后台服务** | `BatteryMonitorService.java` | 持续监控电池状态、计算功耗、更新通知 |
| **数据模型** | `Battery.java` | 电池状态数据封装和处理 |
| **UI布局** | `activity_battery.xml` | 续航预测界面布局 |

### 1.2 数据流图

```
电池系统广播 (BATTERY_CHANGED)
    ↓
BatteryReceiver (BroadcastReceiver)
    ↓
updateBatteryInfo() / handleBatteryChanged()
    ↓
calculatePowerConsumption() ← 计算功耗
    ↓
powerRecords (历史功耗记录)
    ↓
getAvgPower() ← 加权平均算法
    ↓
calculateRemainingTime() / calculateFullRangeTime()
    ↓
UI 更新 / 通知更新
```

---

## 二、UI 界面分析

### 2.1 布局结构 (`activity_battery.xml`)

界面包含三个主要卡片：

#### **卡片 1：电池状态卡片** (`batteryStatusCard`)
```xml
- 电池图标 (batteryIcon) - 根据电量和充电状态动态显示
- 电量百分比 (batteryPercentage) - 当前电量百分比
- 电池状态 (batteryStatus) - "充电中" / "放电中"
- 状态图标 (statusIcon) - 充电/放电图标
- 电池进度条 (batteryProgress) - 0-100% 的进度条
```

#### **卡片 2：电池使用情况卡片** (`usageTimeCard`)
```xml
- 已使用时间 (usedTime) - 本次放电周期的使用时长
- 预计剩余使用时间 (remainingTime) ⭐ 核心功能
- 全程预计续航时间 (fullRangeTime) ⭐ 核心功能
```

#### **卡片 3：使用统计卡片** (`appUsageCard`)
```xml
- 平均功耗 (powerValue) - 当前平均功耗 (mAh/小时)
- 电池容量 (batteryCapacity) - 可点击设置容量
- 上次充满时间 (lastFullChargeTime) - 最后一次充满电的时间
```

### 2.2 关键 UI 元素

| UI 元素 | ID | 说明 |
|---------|----|----- |
| 剩余时间显示 | `remainingTime` | 显示根据当前功耗预测的剩余使用时间 |
| 满电续航显示 | `fullRangeTime` | 显示从 100% 到 0% 的预计总续航时间 |
| 平均功耗显示 | `powerValue` | 显示实时计算的平均功耗，可点击手动调整 |
| 电池容量显示 | `batteryCapacity` | 显示电池容量，可点击手动设置 |

---

## 三、核心算法实现

### 3.1 功耗计算算法

#### **实现位置**: `BatteryActivity.calculatePowerConsumption()`

```java
// 计算逻辑
long timeDiff = now - lastRecordTime;           // 时间差（毫秒）
int percentDiff = lastRecordPercent - newPercent; // 电量差（百分比）
float hoursPassed = timeDiff / 3600000.0f;      // 转换为小时

if (percentDiff > 0) {
    // 消耗的电池容量（mAh）
    float consumed = (batteryCapacity * percentDiff) / 100.0f;
    // 功耗 = 容量 / 时间
    power = consumed / hoursPassed;
} else {
    // 待机状态估算
    power = estimateStandbyPower();
}
```

#### **算法说明**：

1. **触发条件**：
   - 电量下降（`percentDiff > 0`）
   - 或时间超过 1 分钟（`timeDiff >= 60000`）

2. **功耗计算公式**：
   ```
   功耗 (mAh/h) = (电池容量 × 电量下降百分比) / 经过时间（小时）
   ```

3. **数据过滤**：
   - 功耗范围限制：`50.0 - 3000.0 mAh/h`
   - 异常值处理：NaN 和 Infinity 替换为 50.0

4. **历史记录**：
   - 最多保存 **30 条**功耗记录（`MAX_RECORDS = 30`）
   - 采用 FIFO（先进先出）策略

### 3.2 平均功耗计算

#### **实现位置**: `BatteryActivity.getAvgPower()`

```java
// 加权平均算法
float sum = 0.0f;
float weightSum = 0.0f;
for (int i = 0; i < powerRecords.size(); i++) {
    float weight = (i + 1) / powerRecords.size(); // 越新的数据权重越大
    sum += powerRecords.get(i) * weight;
    weightSum += weight;
}
float avgPower = sum / weightSum;
```

#### **算法特点**：

1. **线性加权**：
   - 第 1 条记录权重：1/30
   - 第 30 条记录权重：30/30
   - **越新的数据权重越大**，更能反映当前实际功耗

2. **手动覆盖**：
   - 用户可通过点击"平均功耗"卡片手动设置
   - 手动值优先级最高（`manualPower > 0`）

3. **待机估算**：
   - 无历史数据时，取最近 5 条记录平均值
   - 完全无数据时，使用默认值 50.0 mAh/h

### 3.3 剩余时间预测算法

#### **实现位置**: `BatteryActivity.calculateRemainingTime()`

```java
// 剩余容量（mAh）
float remainingCapacity = (batteryCapacity * currentPercent) / 100.0f;

// 剩余时间（小时）
float remainHours = remainingCapacity / avgPower;

// 格式化输出
int remHours = (int) remainHours;
int remMins = (int) ((remainHours - remHours) * 60.0f);
```

#### **预测公式**：
```
剩余时间 (小时) = (电池容量 × 当前电量%) / 平均功耗
```

#### **边界处理**：
- 超过 168 小时（7 天）显示："超过7天"
- 小于 1 分钟显示："1分钟"
- 计算异常显示："计算中..."
- 充电状态显示："--"

### 3.4 满电续航预测算法

#### **实现位置**: `BatteryActivity.calculateFullRangeTime()`

```java
// 满电容量
float fullCapacity = batteryCapacity;

// 满电续航时间（小时）
float fullRangeHours = fullCapacity / avgPower;

// 格式化输出
int fullHours = (int) fullRangeHours;
int fullMins = (int) ((fullRangeHours - fullHours) * 60.0f);
```

#### **预测公式**：
```
满电续航 (小时) = 电池容量 / 平均功耗
```

#### **说明**：
- 假设从 100% 使用到 0%
- 基于当前功耗模式
- 不考虑充电状态

---

## 四、电池监控机制

### 4.1 广播接收器

#### **BatteryActivity 中的广播监听**：

```java
IntentFilter filter = new IntentFilter();
filter.addAction("android.intent.action.BATTERY_CHANGED");
filter.addAction("android.intent.action.ACTION_POWER_CONNECTED");
filter.addAction("android.intent.action.ACTION_POWER_DISCONNECTED");
filter.addAction("android.intent.action.BATTERY_LOW");
filter.addAction("android.intent.action.BATTERY_OKAY");
registerReceiver(batteryReceiver, filter);
```

#### **监听的系统事件**：
- `BATTERY_CHANGED` - 电池状态变化（主要数据源）
- `ACTION_POWER_CONNECTED` - 充电器连接
- `ACTION_POWER_DISCONNECTED` - 充电器断开
- `BATTERY_LOW` - 电量低
- `BATTERY_OKAY` - 电量恢复正常

### 4.2 定时更新机制

#### **BatteryActivity**：
```java
UPDATE_INTERVAL = 30000 // 30 秒更新一次
mainHandler.postDelayed(updateTask, UPDATE_INTERVAL);
```

#### **BatteryMonitorService**：
```java
UPDATE_INTERVAL = 60000 // 60 秒更新通知
```

### 4.3 充放电状态切换处理

#### **充电开始时**：
```java
if (newCharging) {
    powerRecords.clear();        // 清空功耗记录
    manualPower = 0.0f;          // 重置手动设置
    Log.d(TAG, "Charging started, cleared power records");
}
```

#### **放电开始时**：
```java
else {
    dischargeStartTime = System.currentTimeMillis();  // 记录放电开始时间
    lastRecordTime = System.currentTimeMillis();
    lastRecordPercent = newPercent;
    Log.d(TAG, "Discharging started");
}
```

### 4.4 满电检测

```java
boolean isFull = status == 5; // BatteryManager.BATTERY_STATUS_FULL
if (isFull) {
    lastFullTimestamp = System.currentTimeMillis();
    Log.i(TAG, "Battery fully charged at: " + lastFullTimestamp);
}
```

---

## 五、数据持久化

### 5.1 SharedPreferences 存储

#### **存储位置**: `BatteryPrefs`

#### **存储的数据项**：

| 键名 | 数据类型 | 说明 |
|------|---------|------|
| `capacity` | int | 电池容量（mAh） |
| `lastRecordTime` | long | 上次记录时间戳 |
| `lastRecordPercent` | int | 上次记录电量百分比 |
| `dischargeStart` | long | 放电开始时间戳 |
| `isCharging` | boolean | 当前充电状态 |
| `lastFull` | long | 上次充满电时间戳 |
| `manualPower` | float | 手动设置的功耗值 |
| `firstLaunch` | boolean | 是否首次启动 |
| `powerCount` | int | 功耗记录数量 |
| `power_0` ~ `power_29` | float | 历史功耗记录（最多 30 条） |

#### **保存时机**：
```java
// BatteryActivity
- updateBatteryInfo() 更新电池信息后
- showPowerDialog() 手动调整功耗后
- showCapacityDialog() 设置容量后
- onPause() 界面暂停时
- onDestroy() 界面销毁时

// BatteryMonitorService
- handleBatteryChanged() 电池状态变化后
- onDestroy() 服务销毁时
```

### 5.2 状态恢复

#### **实现位置**: `BatteryActivity.restoreState()`

```java
lastRecordTime = prefs.getLong("lastRecordTime", currentTime);
lastRecordPercent = prefs.getInt("lastRecordPercent", -1);
dischargeStartTime = prefs.getLong("dischargeStart", currentTime);
isCharging = prefs.getBoolean("isCharging", false);
batteryCapacity = prefs.getInt("capacity", getBatteryCapacity());
manualPower = prefs.getFloat("manualPower", 0.0f);

// 恢复功耗记录
int count = prefs.getInt("powerCount", 0);
for (int i = 0; i < count; i++) {
    float power = prefs.getFloat("power_" + i, 0.0f);
    if (power > 0.0f) {
        powerRecords.add(power);
    }
}
```

---

## 六、后台服务 (BatteryMonitorService)

### 6.1 服务特性

- **前台服务**：通过 `startForeground()` 保持服务不被杀死
- **常驻通知**：显示电池状态和功耗信息
- **WakeLock**：防止系统休眠中断监控（持续 10 分钟）
- **电池优化白名单**：请求用户将应用加入白名单

### 6.2 通知内容

#### **通知标题**：
```
KBattery 电池监控
```

#### **通知内容**：
```
电池状态: [充电/放电] | 功耗: [X.X mAh/小时]
```

#### **展开内容**：
```
当前电量: XX%
电池状态: [充电/放电]
当前功耗: [X.X mAh/小时]
电池容量: XXXX mAh
更新时间: HH:mm:ss
```

### 6.3 服务生命周期

```java
onCreate()
  ↓
loadBatteryCapacity()      // 加载电池容量
  ↓
acquireWakeLock()          // 获取唤醒锁
  ↓
createNotificationChannel() // 创建通知渠道
  ↓
startForeground()          // 启动前台服务
  ↓
registerBatteryReceiver()  // 注册广播接收器
  ↓
持续监控...
  ↓
onDestroy()
  ↓
releaseWakeLock()          // 释放唤醒锁
  ↓
unregisterReceiver()       // 取消注册接收器
  ↓
saveState()                // 保存状态
```

---

## 七、用户交互功能

### 7.1 手动设置电池容量

#### **触发方式**：
- 首次启动应用（强制设置，不可取消）
- 点击"电池容量"卡片

#### **实现逻辑**：
```java
showCapacityDialog(boolean force) {
    // 输入验证：500 - 20000 mAh
    int capacity = Integer.parseInt(inputStr);
    if (capacity >= 500 && capacity <= 20000) {
        batteryCapacity = capacity;
        powerRecords.clear(); // 清空功耗记录，重新计算
        saveState();
    }
}
```

#### **影响**：
- 清空所有历史功耗记录
- 重新开始计算功耗和续航
- 持久化保存

### 7.2 手动调整功耗

#### **触发方式**：
- 点击"平均功耗"卡片

#### **实现逻辑**：
```java
showPowerDialog() {
    // 输入验证：50.0 - 3000.0 mAh/h
    float power = Float.parseFloat(inputStr);
    if (power >= 50.0f && power <= 3000.0f) {
        manualPower = power;       // 设置手动功耗
        powerRecords.clear();      // 清空历史记录
        updateUI();                // 立即更新界面
        saveState();
    }
}
```

#### **重置功能**：
```java
// 点击"重置"按钮
manualPower = 0.0f;
powerRecords.clear();
// 恢复自动计算模式
```

### 7.3 UI 动画效果

#### **进度条动画**：
```java
animateProgressBar(int progress) {
    ObjectAnimator progressAnimator = ObjectAnimator.ofInt(
        batteryProgress, "progress", progress
    );
    progressAnimator.setDuration(1000L); // 1 秒动画
    progressAnimator.start();
}
```

#### **入场动画**：
```java
startEntranceAnimation() {
    // 四个卡片依次淡入 + 上滑
    card.animate()
        .alpha(1.0f)
        .translationY(0.0f)
        .setStartDelay(i * 150 + 100) // 错开 150ms
        .setDuration(500L)
        .start();
}
```

---

## 八、电池图标动态显示

### 8.1 图标资源映射

#### **充电状态**：
```java
if (isCharging) {
    if (currentPercent >= 90)      → battery_charging_full
    else if (currentPercent >= 70) → battery_charging_70
    else if (currentPercent >= 50) → battery_charging_50
    else if (currentPercent >= 30) → battery_charging_30
    else                           → battery_charging_low
}
```

#### **放电状态**：
```java
else {
    if (currentPercent >= 90)      → battery_full
    else if (currentPercent >= 70) → battery_70
    else if (currentPercent >= 50) → battery_50
    else if (currentPercent >= 30) → battery_30
    else                           → battery_low
}
```

### 8.2 进度条颜色

```xml
<!-- progress_bar_gradient.xml -->
渐变色进度条，从绿色到红色
```

---

## 九、关键常量定义

| 常量名 | 值 | 说明 |
|--------|----|----- |
| `MAX_RECORDS` | 30 | 最大功耗记录数量 |
| `MAX_BATTERY_CAPACITY` | 20000 | 最大电池容量 (mAh) |
| `MIN_POWER` | 50.0 | 最小功耗限制 (mAh/h) |
| `MAX_POWER` | 3000.0 | 最大功耗限制 (mAh/h) |
| `MAX_PREDICT_HOURS` | 168.0 | 最大预测时长（7 天） |
| `UPDATE_INTERVAL` (Activity) | 30000 | 界面更新间隔 (30 秒) |
| `UPDATE_INTERVAL` (Service) | 60000 | 服务更新间隔 (60 秒) |

---

## 十、功能流程总结

### 10.1 完整工作流程

```
[应用启动]
    ↓
1. MainActivity 初始化
    ↓
2. 启动 BatteryMonitorService (前台服务)
    ↓
3. 跳转 BatteryActivity (通过 ViewPager)
    ↓
4. 恢复历史状态 (restoreState)
    ↓
5. 获取电池容量
    ├─ 从 SharedPreferences 读取
    └─ 或从 BatteryManager 检测
    ↓
6. 首次启动？
    ├─ 是 → 显示电池容量设置对话框
    └─ 否 → 继续
    ↓
7. 注册电池广播接收器
    ↓
8. 启动定时更新任务 (30 秒)
    ↓
[持续监控]
    ↓
9. 接收电池状态广播
    ↓
10. 充电状态检测
    ├─ 充电 → 清空功耗记录，显示 "--"
    └─ 放电 → 继续
    ↓
11. 电量变化 > 0？
    ├─ 是 → 计算功耗
    │     ↓
    │     功耗 = (容量 × 电量差%) / 时间差
    │     ↓
    │     添加到 powerRecords
    └─ 否 → 跳过
    ↓
12. 计算加权平均功耗
    ↓
13. 预测剩余时间
    └─ 剩余时间 = (容量 × 当前电量%) / 平均功耗
    ↓
14. 预测满电续航
    └─ 满电续航 = 容量 / 平均功耗
    ↓
15. 更新 UI
    ├─ 电量百分比
    ├─ 电池图标
    ├─ 充放电状态
    ├─ 已使用时间
    ├─ 剩余时间 ⭐
    ├─ 满电续航 ⭐
    ├─ 平均功耗
    └─ 进度条动画
    ↓
16. 保存状态到 SharedPreferences
    ↓
17. 更新通知 (BatteryMonitorService)
    ↓
[循环回步骤 9]
```

### 10.2 数据计算链路

```
电池系统 (BatteryManager)
    ↓
【原始数据】
  - level: 50
  - scale: 100
  - status: DISCHARGING
    ↓
【计算百分比】
  currentPercent = (50 / 100) * 100 = 50%
    ↓
【功耗计算】
  时间差: 3600000 ms (1 小时)
  电量差: 10% (60% → 50%)
  容量: 4000 mAh
  消耗容量 = 4000 * 0.1 = 400 mAh
  功耗 = 400 / 1 = 400 mAh/h
    ↓
【功耗记录】
  powerRecords = [350, 380, 420, 400, ...] (最多 30 条)
    ↓
【加权平均】
  avgPower = Σ(power[i] * weight[i]) / Σweight[i]
  例如: 390 mAh/h
    ↓
【剩余时间预测】
  剩余容量 = 4000 * 0.5 = 2000 mAh
  剩余时间 = 2000 / 390 ≈ 5.13 小时
  格式化: "5小时8分钟"
    ↓
【满电续航预测】
  满电容量 = 4000 mAh
  满电续航 = 4000 / 390 ≈ 10.26 小时
  格式化: "10小时16分钟"
    ↓
【显示到 UI】
```

---

## 十一、优缺点分析

### 11.1 优点

✅ **算法设计合理**：
- 加权平均算法，越新的数据权重越大
- 异常值过滤，避免极端数据干扰
- 边界处理完善，避免计算溢出

✅ **用户体验良好**：
- 支持手动设置容量和功耗
- 首次使用引导
- 动画效果流畅
- 实时更新

✅ **数据持久化**：
- 完整的状态保存和恢复
- 历史功耗记录保存
- 应用重启后能继续计算

✅ **后台监控**：
- 前台服务保证持续运行
- 通知栏实时显示
- WakeLock 防止休眠

### 11.2 缺点与局限

❌ **预测精度问题**：
- 基于历史平均功耗，无法预测使用场景变化
- 例如：当前待机功耗 100 mAh/h，玩游戏可能达到 1000 mAh/h
- 无法区分不同应用的功耗差异

❌ **数据采样限制**：
- 只在电量变化时记录
- 低功耗待机时，可能很久才变化 1%
- 导致采样间隔不均匀

❌ **容量检测不准**：
```java
// 尝试从系统获取容量，但可能失败
BatteryManager.getLongProperty(4);
```
- 部分设备无法读取真实容量
- 降级使用默认 4000 mAh

❌ **功耗计算异常场景**：
- 充电过程中清空所有记录
- 重新拔下充电器后需要重新积累数据
- 导致短时间内预测不准

❌ **边界条件处理**：
- `lastRecordPercent == -1` 时不计算功耗
- 首次启动时预测显示 "--"
- 需要等待至少一次电量变化

---

## 十二、技术亮点

### 12.1 加权平均算法

```java
// 线性加权，越新权重越大
for (int i = 0; i < powerRecords.size(); i++) {
    float weight = (i + 1) / powerRecords.size();
    sum += powerRecords.get(i) * weight;
    weightSum += weight;
}
```
- 优点：体现最新使用模式
- 缺点：权重分布固定，无法动态调整

### 12.2 异常值处理

```java
private float filterPower(float power) {
    if (Float.isNaN(power) || Float.isInfinite(power)) {
        return 50.0f; // 默认值
    }
    return Math.max(50.0f, Math.min(3000.0f, power)); // 钳位
}
```

### 12.3 待机功耗估算

```java
private float estimateStandbyPower() {
    if (!powerRecords.isEmpty()) {
        // 取最近 5 条记录的平均值
        int count = Math.min(powerRecords.size(), 5);
        float sum = 0.0f;
        for (int i = powerRecords.size() - 1; i >= powerRecords.size() - count; i--) {
            sum += powerRecords.get(i);
        }
        return sum / count;
    }
    return 50.0f; // 无数据时的默认值
}
```

### 12.4 前台服务保活

```java
// 创建前台服务，显示常驻通知
startForeground(NOTIFICATION_ID, notification);

// 获取 WakeLock 防止休眠
wakeLock.acquire(600000L); // 10 分钟
```

---

## 十三、改进建议

### 13.1 预测精度提升

建议引入**场景识别**：
```
- 待机场景：功耗 50-100 mAh/h
- 轻度使用：功耗 200-500 mAh/h
- 重度使用：功耗 800-1500 mAh/h
- 游戏场景：功耗 1000-3000 mAh/h
```

通过以下信息识别场景：
- 屏幕开关状态
- CPU 使用率
- GPS、蓝牙、WiFi 状态
- 前台应用类别

### 13.2 数据采样优化

建议定时主动采样：
```java
// 即使电量未变化，每 5 分钟记录一次
scheduledExecutor.scheduleAtFixedRate(
    () -> estimateCurrentPower(),
    0, 5, TimeUnit.MINUTES
);
```

### 13.3 电池健康度分析

增加电池健康度评估：
```
实际容量 / 标称容量 * 100% = 健康度
```

通过多次完整充放电周期计算实际容量。

### 13.4 历史趋势图

增加功耗趋势图：
```
使用 MPAndroidChart 绘制折线图
X 轴：时间
Y 轴：功耗 (mAh/h)
```

帮助用户直观了解功耗变化。

---

## 十四、总结

### 核心功能实现质量：⭐⭐⭐⭐ (4/5)

KBattery 的续航预测功能在反编译的 Android 应用中属于**中等偏上**的实现水平：

**做得好的地方**：
1. ✅ 核心算法逻辑清晰，功耗计算公式正确
2. ✅ 加权平均算法合理，体现最新使用模式
3. ✅ 异常处理完善，避免崩溃
4. ✅ 数据持久化完整，支持状态恢复
5. ✅ 后台服务设计合理，保证持续监控
6. ✅ UI 设计简洁，交互流畅

**需要改进的地方**：
1. ❌ 预测精度受限于历史平均功耗，无场景识别
2. ❌ 数据采样依赖电量变化，间隔不均匀
3. ❌ 容量检测可能失败，依赖手动设置
4. ❌ 充电后数据重置，需重新积累
5. ❌ 无历史趋势分析和可视化

### 适用场景：

✅ 适合：
- 日常轻度使用场景
- 功耗相对稳定的用户
- 需要快速估算剩余时间

❌ 不适合：
- 使用场景频繁切换
- 需要高精度预测
- 专业电池分析需求

---

## 附录：关键代码片段索引

| 功能 | 文件位置 | 行号 |
|------|---------|------|
| 功耗计算 | `BatteryActivity.java` | 317-341 |
| 加权平均 | `BatteryActivity.java` | 369-386 |
| 剩余时间预测 | `BatteryActivity.java` | 501-527 |
| 满电续航预测 | `BatteryActivity.java` | 529-555 |
| 电池图标更新 | `BatteryActivity.java` | 557-621 |
| 状态保存 | `BatteryActivity.java` | 755-774 |
| 状态恢复 | `BatteryActivity.java` | 805-828 |
| 后台服务创建 | `BatteryMonitorService.java` | 49-73 |
| 通知创建 | `BatteryMonitorService.java` | 115-149 |

---

**分析完成日期**: 2025-10-29  
**反编译项目版本**: KBattery 1.182  
**分析者**: AI 逆向工程助手

